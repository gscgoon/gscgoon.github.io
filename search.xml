<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>且说西游第一回</title>
    <url>/2021/11/23/%E4%B8%94%E8%AF%B4%E8%A5%BF%E6%B8%B8/</url>
    <content><![CDATA[<p>突然蹦的一声，一个石头中崩裂出一个毛脸雷公（日后被菩提老祖取名悟空），他的到来给在座的每一位的童年带来了回味无穷的记忆…</p>
<p>预知后事如何，且听下回娓娓道来…</p>
<span id="more"></span>

<p>欢迎您的观看，文章更行中，请耐心等待</p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>西游</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL相关知识-02</title>
    <url>/2024/07/30/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-02/</url>
    <content><![CDATA[<p>MySQL的索引相关知识</p>
<p>普通索引</p>
<p>主键索引</p>
<p>唯一索引</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL相关知识-02</title>
    <url>/2024/07/30/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-03/</url>
    <content><![CDATA[<p>MySQL的索引相关知识</p>
<p>普通索引</p>
<p>主键索引</p>
<p>唯一索引</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL相关知识-02</title>
    <url>/2024/07/30/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-04/</url>
    <content><![CDATA[<p>MySQL的索引相关知识</p>
<p>普通索引</p>
<p>主键索引</p>
<p>唯一索引</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL相关知识-02</title>
    <url>/2024/07/30/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-05/</url>
    <content><![CDATA[<p>MySQL的索引相关知识</p>
<p>普通索引</p>
<p>主键索引</p>
<p>唯一索引</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL相关知识-02</title>
    <url>/2024/07/30/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-06/</url>
    <content><![CDATA[<p>MySQL的索引相关知识</p>
<p>普通索引</p>
<p>主键索引</p>
<p>唯一索引</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从复制</title>
    <url>/2024/07/28/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔记录02</title>
    <url>/2024/07/28/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%9502/</url>
    <content><![CDATA[<p>111111111111111111111111111</p>
<p>222222222222222222222222222</p>
<p>2222222222222222222222222222222</p>
<p>222</p>
<p>2</p>
<p>2</p>
<p>2222222222222222222</p>
<p>2</p>
<p>222222222222222222</p>
]]></content>
      <categories>
        <category>随笔记录</category>
      </categories>
      <tags>
        <tag>随笔记录</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔记录</title>
    <url>/2024/07/28/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>12333333333333</p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔记录</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot相关知识点01</title>
    <url>/2024/07/28/SpringBoot%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B901/</url>
    <content><![CDATA[<p>SpringBoot的相关知识的学习记录</p>
<span id="more"></span>



<p>SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录SpringBoot的相关知识的学习记录</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL相关知识-01</title>
    <url>/2024/07/27/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-01/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="dc0484eb65bafab9facddc712273dc484efefb7846e446391aca13c4efb58d0b">ee096cc3e2ae9122439424ae5f81fd56fa6368c3be86cea8932f3093a76e8f01d459921bdc2a2d3b700627812636aa6f9e35fa77609ed071c5764a04233810b28f002f1c8011e8b771b94fe0546dacae1b8b6b231926707875fd42a32a93d097</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-surge">
      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="Hey, password is required here.">Hey, password is required here.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎的一个关于使用Hexo+Butterfly搭建个人博客的宝藏总结</title>
    <url>/2024/07/25/%E7%9F%A5%E4%B9%8E%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Hexo-Butterfly%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%AE%9D%E8%97%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>参考链接</p>
<p><a href="https://www.zhihu.com/question/484633431/answer/3539808024">https://www.zhihu.com/question/484633431/answer/3539808024</a></p>
]]></content>
      <categories>
        <category>借鉴</category>
      </categories>
      <tags>
        <tag>BLog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis--哨兵机制：主库挂了，如何不间断服务</title>
    <url>/2024/07/25/Redis-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%EF%BC%8C%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题：</p>
<span id="more"></span>

<p>1.主库真的挂了吗？</p>
<p>2.该选择哪个从库作为主库？</p>
<p>3.怎么把新主库的相关信息通知给从库和客户端呢？</p>
<p>哨兵机制的基本流程哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。我们先看监控。监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。这个流程首先是执行哨兵的第二个任务，选主。主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。然后，哨兵会执行最后一个任务：通知。在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</p>
<p>这三个任务中，通知任务相对来说比较简单，哨兵只需要把新主库信息发给从库和客户端，让它们和新主库建立连接就行，并不涉及决策的逻辑。但是，在监控和选主这两个任务中，哨兵需要做出两个决策：在监控任务中，哨兵需要判断主库是否处于下线状态；在选主任务中，哨兵也要决定选择哪个从库实例作为主库。</p>
<p><strong>主观下线和客观下线：</strong></p>
<p>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。引出误判情况，需要哨兵集群来进行投票来确定主库是否down掉，通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。</p>
<p>在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了。这个判断原则就是：少数服从多数。同时，这会进一步触发哨兵开始主从切换流程。简单来说，“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。</p>
<p><strong>如何选定新主库？</strong></p>
<p>一般来说，我把哨兵选择新主库的过程称为“筛选 + 打分”。简单来说，我们在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉。然后，我们再按照一定的规则，给剩下的从库逐个打分，将得分最高的从库选为新主库，</p>
<p><strong>首先来看筛选的条件。</strong></p>
<p>一般情况下，我们肯定要先保证所选的从库仍然在线运行。不过，在选主时从库正常在线，这只能表示从库的现状良好，并不代表它就是最适合做主库的。</p>
<p>所以，在选主时，除了要检查从库的当前在线状态，还要判断它之前的网络连接状态。如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。具体怎么判断呢？你使用配置项 down-after-milliseconds * 10。其中，down-after-milliseconds 是我们认定主从库断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。</p>
<p><strong>接下来就要给剩余的从库打分了。</strong></p>
<p>我们可以分别按照三个规则依次进行三轮打分，这三个规则分别是从库优先级、从库复制进度以及从库 ID 号。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。</p>
<p><strong>第一轮：优先级最高的从库得分高。</strong></p>
<p>用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。</p>
<p><strong>第二轮：和旧主库同步程度最接近的从库得分高。</strong></p>
<p>这个规则的依据是，如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。如何判断从库和旧主库间的同步进度呢？上节课我向你介绍过，主从库同步时有个命令传播的过程。在这个过程中，主库会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。此时，我们想要找的从库，它的 slave_repl_offset 需要最接近 master_repl_offset。如果在所有从库中，有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。就像下图所示，旧主库的 master_repl_offset 是 1000，从库 1、2 和 3 的 slave_repl_offset 分别是 950、990 和 900，那么，从库 2 就应该被选为新主库。基于复制进度的新主库选主原则当然，如果有两个从库的 slave_repl_offset 值大小是一样的（例如，从库 1 和从库 2 的 slave_repl_offset 值都是 990），我们就需要给它们进行第三轮打分了。</p>
<p><strong>第三轮：ID 号小的从库得分高。</strong></p>
<p>每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。目前，Redis 在选主库时，有一个默认的规定：在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。到这里，新主库就被选出来了，“选主”这个过程就完成了。我们再回顾下这个流程。首先，哨兵会按照在线状态、网络状态，筛选过滤掉一部分不符合要求的从库，然后，依次按照优先级、复制进度、ID 号大小再对剩余的从库进行打分，只要有得分最高的从库出现，就把它选为新主库。</p>
<p>Redis 的哨兵机制自动完成了以下三大功能，从而实现了主从库的自动切换，可以降低 Redis 集群的运维开销：监控主库运行状态，并判断主库是否客观下线；在主库客观下线后，选取新主库；选出新主库后，通知从库和客户端。为了降低误判率，在实际应用时，哨兵机制通常采用多实例的方式进行部署，多个哨兵实例通过“少数服从多数”的原则，来判断主库是否客观下线。一般来说，我们可以部署三个哨兵，如果有两个哨兵认定主库“主观下线”，就可以开始切换过程。当然，如果你希望进一步提升判断准确率，也可以再适当增加哨兵个数，比如说使用五个哨兵。但是，使用多个哨兵实例来降低误判率，其实相当于组成了一个哨兵集群，我们会因此面临着一些新的挑战，例如：哨兵集群中有实例挂了，怎么办，会影响主库状态判断和选主吗？哨兵集群多数实例达成共识，判断出主库“客观下线”后，由哪个实例来执行主从切换呢？</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之二叉树</title>
    <url>/2021/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>数据结构是新生代农民工急需掌握的一门技术，了解并灵活运用便可给你带来财富，下面介绍的数据结构为–二叉树</p>
<span id="more"></span>

<p><strong>首先是二叉树的概念：</strong></p>
<p>每个节点最多只能有两个子节点(左节点，右节点)的树称之为二叉树</p>
<p><strong>其次是二叉树的分类：</strong></p>
<p>满二叉树：二叉树所有叶子节点(没有子节点)都在最后一层，并且节点总数=2^n -1，n为树的层数</p>
<p>完全二叉树：二叉树所有叶子节点都在最后一层/倒数第二层，并且最后一层叶子节点在左边连续，倒数第二层叶子节点在右边连续</p>
<p><strong>最后是二叉树的遍历：</strong></p>
<p>前序遍历：先父节点，再左子树，最后右子树</p>
<p>中序遍历：先左子树，再父节点，最后右子树</p>
<p>后序遍历：先左子树，再右子树，最后父节点</p>
<p>小结：由此看出，父节点的遍历位置代表着遍历方法</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2021/12/11/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>docker是一项新生代农民工必须掌握的技术，故在此记录关于docker常用的一些命令，以备日常查找时使用。</p>
<span id="more"></span>

<p><img src="/photos/docker.bmp" title="docker 架构图"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">常用命令：<br>帮助3命令：<br>docker version<br>docker info<br>docker --help<br>镜像4命令：<br>docker images 列出本机上所有的镜像<br>docker search 镜像名字<br>docker pull 镜像名字<br>docker rmi 镜像名字ID<br>容器命令：<br>docker run image 启动容器<br>docker ps 列出当前所有正在运行的容器<br>exit-容器停止并退出 /ctrl+p+q-容器不停止退出<br>docker start/restart/stop/kill 容器id或名字 容器的启动/重启/停止/强制停止<br>docker rm 容器id 删除已停止容器<br>docker rm -f $(docker ps -qa) 一次性删除多个容器<br><br><br><br>attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像<br>build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像<br>commit    Create a new image from a container changes   # 提交当前容器为新的镜像<br>cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中<br>create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器<br>diff      Inspect changes on a container&#x27;s filesystem   # 查看 docker 容器变化<br>events    Get real time events from the server          # 从 docker 服务获取容器实时事件<br>exec      Run a command in an existing container        # 在已存在的容器上运行命令<br>export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]<br>history   Show the history of an image                  # 展示一个镜像形成历史<br>images    List images                                   # 列出系统当前镜像<br>import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]<br>info      Display system-wide information               # 显示系统相关信息<br>inspect   Return low-level information on a container   # 查看容器详细信息<br>kill      Kill a running container                      # kill 指定 docker 容器<br>load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]<br>login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器<br>logout    Log out from a Docker registry server          # 从当前 Docker registry 退出<br>logs      Fetch the logs of a container                 # 输出当前容器日志信息<br>port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口<br>pause     Pause all processes within a container        # 暂停容器<br>ps        List containers                               # 列出容器列表<br>pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像<br>push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器<br>restart   Restart a running container                   # 重启运行的容器<br>rm        Remove one or more containers                 # 移除一个或者多个容器<br>rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]<br>run       Run a command in a new container              # 创建一个新的容器并运行一个命令<br>save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]<br>search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像<br>start     Start a stopped containers                    # 启动容器<br>stop      Stop a running containers                     # 停止容器<br>tag       Tag an image into a repository                # 给源中镜像打标签<br>top       Lookup the running processes of a container   # 查看容器中运行的进程信息<br>unpause   Unpause a paused container                    # 取消暂停容器<br>version   Show the docker version information           # 查看 docker 版本号<br>wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
